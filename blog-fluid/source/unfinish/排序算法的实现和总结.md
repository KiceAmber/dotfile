---
title: 排序算法的实现和总结
date: 2023-11-23 13:18:10
tags:
  - 算法
  - Golang
  - 面试系列 
---

# 冒泡排序

比较相邻的元素，如果第一个比第二个大，就交换他们的顺序，对每一对相邻的元素作同样的工作，从开始第一对到结尾的最后一对

每一趟排序，最大的元素都会像泡泡一样冒出来，被排序到末尾，所以称之为 **冒泡排序**

> 时间复杂度: O(n^2) 空间复杂度: O(1)

```go
func BubbleSort(arr []int) []int {
	for i := 0; i < len(arr); i++ {
		for j := 0; j < len(arr)-1-i; j++ {
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
		}
	}
	return arr
}
```

# 选择排序

从未排序的序列中找到最小(最大)的元素，放置到排序序列的起始位置，此时最小的元素已经找到

然后依次查找第二个最小的元素，再将其放置到第二个位置，重复上述过程，直到所有的元素都排好序

> 时间复杂度: O(n^2) 空间复杂度: O(1)

```go
func SelectionSort(arr []int) []int {
	for i := 0; i < len(arr); i++ {
		minValIdx := i
		for j := i + 1; j < len(arr); j++ {
			if arr[j] < arr[minValIdx] {
				minValIdx = j
			}
		}
		arr[minValIdx], arr[i] = arr[i], arr[minValIdx]
	}
	return arr
}
```

# 插入排序

该排序的思想就是将整个序列分成待排序和已排序两类，已排序在前，待排序在后

将序列的第一个元素看作是已排序的第一个元素，将待排序的元素依次与已排序的元素进行比较，插入到合适的位置

> 时间复杂度: O(n^2) 空间复杂度: O(1)

```go
func InsertionSort(arr []int) []int {
	// 从下标为 1 开始，下标为 0 的元素默认为排好序的
	for i := 1; i < len(arr); i++ {
		curr := arr[i]
		j := i - 1 // j 赋值为 i-1 就是从已排序的最后一个开始往前面遍历
		for ; j >= 0; j-- {
			if curr < arr[j] { // 如果排好序中的元素值大于选中的元素，就往后移
				arr[j+1] = arr[j]
			} else {
				break
			}
		}
		arr[j+1] = curr // 退出 for 循环后，此时的 j+1 位置就是要插入的下标
	}
	return arr
}
```

# 归并排序

归并排序也是包含了 **分治** 的思想，将序列对半划分，直到划分为单个元素为一组，最后每两组进行比较大小，实现排序

归并排序的整个过程示例：

![image-20230918101624.png](https://z1.ax1x.com/2023/11/24/piwlOiD.png)

> 时间复杂度: O(nlogn) 空间复杂度: O(n)

```go
func MergeSort(arr []int) []int {
	if len(arr) <= 1 {
		return arr
	}

	// 将数组分为两半
	mid := len(arr) / 2
	left := MergeSort(arr[:mid])
	right := MergeSort(arr[mid:])

	// 合并两个数组
	return merge(left, right)
}

// merge 合并数组
func merge(left []int, right []int) []int {
	res := make([]int, 0)

	// 比较元素，按顺序合并
	for len(left) > 0 && len(right) > 0 {
		if left[0] < right[0] {
			res = append(res, left[0])
			left = left[1:]
		} else {
			res = append(res, right[0])
			right = right[1:]
		}
	}

	// 将剩下的元素追加到结果数组中
	res = append(res, left...)
	res = append(res, right...)
	return res
}
```

# 快速排序

快速排序的思想就是根据挑选 **基准值** 来进行排序，而且有 **分而治之** 的思想，就是将一个序列分为两个子序列，快速排序可以算是在冒泡排序基础上的递归分治法

> 基准值一般挑选序列的最左值或者最右值

快速排序的主要步骤分为三步：

- 从序列中挑选一个元素，称为基准(pivot)
- 重新给序列排序，所有元素比基准值小的都放在基准值的前面，比基准值大的都放在基准值的后面，相同则任意一边都可以。这样该基准值就处于该序列的中间位置，也被称为 **分区** 操作
- 随后递归的在左边和右边的序列进行上述同样的步骤

> 时间复杂度: O(nlogn) 空间复杂度: O(logn)

```go
func QuickSort(arr []int) {
	if len(arr) <= 1 {
		return
	}

	pivot := arr[0]            // 将序列的最左侧元素作为基准值
	low, high := 0, len(arr)-1 // 同时新创建两个指针，分别从最左侧和最右侧的开始遍历序列
	for low < high {
		for arr[high] >= pivot && low < high {
			high--
		}
		// 此时将右侧 high 指针的值放到最左侧的 low 指针位置
		arr[low] = arr[high]

		for arr[low] <= pivot && low < high {
			low++
		}
		// 此时将左侧 low 指针的值放到最右侧的 high 指针位置
		arr[high] = arr[low]
	}
	// 跳出 for 循环后，将 pivot 指针插入到 low 与 high 相遇的位置
	arr[low] = pivot
	// 随后进行左侧序列递归和右侧序列递归
	QuickSort(arr[:low])
	QuickSort(arr[low+1:])
}
```

> 快速排序参考资料：https://zhuanlan.zhihu.com/p/642152546

